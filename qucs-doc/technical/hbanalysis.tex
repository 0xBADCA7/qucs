%
% This document contains the chapter about harmonic balance analysis.
%
% Copyright (C) 2005, 2006 Stefan Jahn <stefan@lkcc.org>
% Copyright (C) 2005, 2006
%               Michael Margraf <Michael.Margraf@alumni.TU-Berlin.DE>
%
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.1
% or any later version published by the Free Software Foundation.
%

\chapter{Harmonic Balance Analysis}
\label{sec:hb_analysis}

Harmonic balance is a non-linear, frequency-domain, steady-state
simulation.  The voltage and current sources create discrete
frequencies resulting in a spectrum of discrete frequencies at every
node in the circuit. Linear circuit components are solely modeled in
frequency domain. Non-linear components are modeled in time domain and
Fourier-transformed before each solving step.  The informations in
this chapter are taken from \cite{Maas1} (chapter 3) which is a very
nice and well-written publication on this topic.

\addvspace{12pt}

The harmonic balance simulation is ideal for situations where
transient simulation methods are problematic. These are:
\begin{itemize}
\item components modeled in frequency domain, for instance (dispersive)
      transmission lines
\item circuit time constants large compared to period of simulation
      frequency
\item circuits with lots of reactive components
\end{itemize}
Harmonic balance methods, therefore, are the best choice for most microwave
circuits excited with sinusoidal signals (e.g. mixers, power amplifiers).


\section{The Basic Concept}

As non-linear elements can only be modeled in time domain, the circuit
first must be separated into a linear and a non-linear part. The
internal impedances $Z_i$ of the voltage sources are put into the
linear part as well. Figure \ref{fig:hb_concept} illustrates the
concept. Let us define the following symbols:
\begin{description}
\item[] M = number of (independent) voltage sources
\item[] N = number of connections between linear and non-linear subcircuit
\item[] K = number of calculated harmonics
\item[] L = number of nodes in linear subcircuit
\end{description}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=9cm]{hb_concept}
\end{center}
\caption{circuit partitioning in harmonic balance}
\label{fig:hb_concept}
\end{figure}
\FloatBarrier

The linear circuit is modeled by two transadmittance matrices:
The first one $\tilde{\boldsymbol{Y}}$
relates the source voltages $v_{S,1}...v_{S,M}$ to the interconnection
currents $i_1...i_N$ and the second one $\hat{\boldsymbol{Y}}$
relates the interconnection
voltages $v_1...v_N$ to the interconnection currents $i_1...i_N$.
Taking both, we can express the current flowing through the
interconnections between linear and non-linear subcircuit:

\begin{equation}
\label{eqn:HBlin}
\boldsymbol{I}
  = \boldsymbol{\tilde{Y}}_{N\times M}\cdot \boldsymbol{V}_S +
    \boldsymbol{\hat{Y}}_{N\times N}\cdot \boldsymbol{V}
  = \boldsymbol{I}_S + \boldsymbol{\hat{Y}}\cdot \boldsymbol{V}
\end{equation}
Because $\boldsymbol{V}_S$ is known and constant, the first term
can already be computed to give $\boldsymbol{I}_S$. Taking the
whole linear network as one block is called the "piecewise"
harmonic balance technique.

\addvspace{12pt}

The non-linear circuit is modeled by its current function
$i(t) = f_g(v_1, ..., v_P)$
and by the charge of its capacitances
$q(t) = f_q(v_1, ..., v_Q)$.
These functions must be Fourier-transformed to give the
frequency-domain vectors $\boldsymbol{Q}$ and $\boldsymbol{I}_G$,
respectively.

\addvspace{12pt}

A simulation result is found if the currents through the
interconnections are the same for the linear and the non-linear
subcircuit. This principle actually gave the harmonic balance
simulation its name, because through the interconnections the
currents of the linear and non-linear subcircuits have to be
\textit{balanced} at every \textit{harmonic} frequency. To
be precise the described method is called Kirchhoff's current
law harmonic balance (KCL-HB). Theoretically, it would also be
possible to use an algorithm that tries to balance the voltages
at the subcircuit interconnections. But then the Z matrix (linear
subcircuit) and current-dependend voltage laws (non-linear
subcircuit) have to be used. That doesn't fit the need (see other
simulation types).

\addvspace{12pt}

So, the non-linear equation system that needs to be solved writes:
\begin{equation}
\label{eqn:HBeqn}
\textbf{F}(\textbf{V})
  = \underbrace{(\boldsymbol{I}_S) + (\boldsymbol{\hat{Y}})\cdot (\boldsymbol{V})}_{\text{linear}}
  + \underbrace{j\cdot \boldsymbol{\Omega}\cdot \boldsymbol{Q} + \boldsymbol{I}_G}_{\text{non-linear}}
  = \boldsymbol{0}
\end{equation}
where matrix $\boldsymbol{\Omega}$ contains the angular frequencies
on the first main diagonal and zeros anywhere else, $\boldsymbol{0}$
is the zero vector.

\addvspace{12pt}

After each iteration step, the inverse Fourier transformation must
be applied to the voltage vector $\boldsymbol{V}$. Then the time domain
voltages $v_{0,1}...v_{K,N}$ are put into $i(t) = f_g(v_1, ..., v_P)$
and $q(t) = f_q(v_1, ..., v_Q)$ again. Now, a Fourier transformation
gives the vectors $\boldsymbol{Q}$ and $\boldsymbol{I}_G$ for the
next iteration step. After repeating this several times, a simulation
result has hopefully be found.

\addvspace{12pt}

Having found this result means having got the voltages $v_1...v_N$ at
the interconnections of the two subcircuits. With these values the
voltages at all nodes can be calculated: Forget about the non-linear
subcircuit, put current sources at the former interconnections (using
the calculated values) and perform a normal AC simulation. After that
the simulation is complete.

\section{Going through each Step}

\subsection{Creating Transadmittance Matrix}

It needs several steps to get the transadmittance matrices $[\tilde{Y}]$
and $[\hat{Y}]$ mentioned in equation \eqref{eqn:HBlin}. First the MNA
matrix of the linear subcircuit (figure \ref{fig:hb_concept}) is created
(chapter \ref{sec:MNA}) without the voltage sources $S_1$...$S_M$ and
without the non-linear components. Note that all nodes must appear in the
matrix, even those where only non-linear components are connected. Then
the transimpedance matrix is derived by
exciting one by one the port nodes of the MNA matrix with unity current.
After that the transadmittance matrix is calculated by inverting the
transimpedance matrix. Finally the matrices $[\tilde{Y}]$ and $[\hat{Y}]$
are filled with the corresponding elements of the overall transadmittance
matrix.

\addvspace{12pt}

Note: The MNA matrix of the linear subcircuit has $L$ nodes.
Every node, that is connected to the non-linear subcircuit or/and is
connected to a voltage source, is called "port" in the following text.
So, there are $M+N$ ports. The $N$ ports of the interconnections are
all with reference to ground, whereas the other $M$ ports can be
differential.

\addvspace{12pt}

Now this should be described in more detail: By use of the MNA matrix
$[A]$, the $n$-th column of the transimpedance matrix $[Z]$ should be
calculated. The voltage source at port $n$ is connected to node $i$
(positive terminal) and to node $j$ (negative terminal). This results
in the following equation. (If port $n$ is referenced to ground, the
-1 is simply omitted.)
\begin{equation}
\label{eqn:HBtrans}
[A]\cdot
\begin{bmatrix}
V_1\\
\vdots\\
V_L\\
\end{bmatrix}
=
\begin{bmatrix}
0\\
\vdots\\
1\\
\vdots\\
-1\\
\vdots\\
0\\
\end{bmatrix}
\begin{matrix}
 \\
 \\
\leftarrow i\text{-th row}\\
 \\
\leftarrow j\text{-th row}\\
 \\
 \\
\end{matrix}
\end{equation}
After having solved it, $Z_{1,n}$...$Z_{N+M,n}$ are obtained
simply by subtraction of the node voltages:
\begin{equation}
Z_{m,n} = V_k - V_l
\end{equation}
Here the voltage source at port $m$ is connected to node $k$
(positive terminal) and to node $l$ (negative terminal).

\addvspace{12pt}

The next column of $[Z]$ is obtained by changing the right-hand
side of equation \eqref{eqn:HBtrans} appropriately. As this has to
be done $N+M$ times, it is strongly recommended to use LU
decomposition.

\addvspace{12pt}

As $[\tilde{Y}]$ is not square, problems encounter by trying to
build its inverse matrix. Therefore, the following procedure is
recommended:
\begin{itemize}
\item Create the transimpedance matrix for all ports (sources
  and interconnections).
\item Compute the inverse matrix (transadmittance matrix).
\item The upper left and upper right corner contains $[\tilde{Y}]$
  and $[\hat{Y}]$.
\item The lower left and lower right corner contains the transadmittance
  matrices to calculate the currents through the sources. They
  can be used to simplify the AC simulation at the very end.
\end{itemize}


\addvspace{12pt}

One further thing must be mentioned: Because the non-linear
components and the sources are missing in the linear MNA matrix,
there are often components that are completely disconnected from
the rest of the circuit. The resulting MNA matrix cannot be
solved. To avoid this problem, shunt each port with a $100\Omega$
resistor, i.e. place a resistor in parallel to each non-linear
component and to each source. The effect of these resistors can
be easily removed by subtracting 10mS from the first main diagonal
of the transadmittance matrix.


\subsection{Frequency-Time Domain Transformation}

During every iteration step of the harmonic balance, the time domain
values have to be transformed into frequency domain and afterwards
back again. This is done by the so-called Fourier Transformation and
the inverse Fourier Transformation, respectively:
\begin{eqnarray}
\text{Fourier Transformation:} & \qquad &
     \underline{U}(j\omega) =
     \int\limits_{-\infty}^{\infty} u(t)\cdot e^{-j\omega\cdot t} \; dt \\
\text{inverse Fourier Transformation:} & \qquad &
     u(t) = \frac{1}{2\pi} \cdot \int\limits_{-\infty}^{\infty}
            \underline{U}(j\omega)\cdot e^{j\omega\cdot t} \; d\omega
\end{eqnarray}
In digital systems the data $u(t)$ or $\underline{U}(j\omega)$,
respectively, consists of a finite number $N$ of samples $u_k$ and
$\underline{U}_n$. This leads to the discrete Fourier Transformation
(DFT) and its inverse operation (IDFT):
\begin{eqnarray}
\label{eqn:DFT}
\text{DFT:} & \qquad &
     \underline{U}_n =
     \sum_{k=0}^{N-1} u_k\cdot \exp\left( -j\cdot n\frac{2\pi\cdot k}{N} \right) \\
\label{eqn:IDFT}
\text{IDFT:} & \qquad &
     u_k = \frac{1}{N} \cdot \sum_{n=0}^{N}
            \underline{U}_n\cdot \exp\left( j\cdot k\frac{2\pi\cdot n}{N} \right)
\end{eqnarray}
The absolute time and frequency values do not appear anymore in the DFT.
They depend on the sample frequency $f_T$ and the number of samples $N$.
\begin{equation}
\Delta f = \frac{1}{N\cdot\Delta t} = \frac{f_T}{N}
\end{equation}
Where $\Delta t$ is distance between time samples and $\Delta f$
distance between frequency samples.

\addvspace{12pt}

With DFT the $N$ time samples are transformed into $N$ frequency samples.
This also holds if the time data are real numbers, as is always
the case in "real life": The complex frequency samples are conjugate
complex symmetrical and so equalizing the score:
\begin{equation}
\underline{U}_{N-n} = \underline{U}_n^*
\end{equation}

\addvspace{12pt}

That is, knowing the input data has no imaginary part, only half of
the Fourier data must be computed.

\addvspace{12pt}

As can be seen in equation \ref{eqn:DFT} the computing time of the
DFT rises with $N^2$. This is really huge. Because this transformation
must be performed many times during harmonic balance simulation, it is
very important to reduce the time consumption. Using a strongly
optimized algorithm, the so-called Fast Fourier Transformation (FFT),
the DFT is reduced to an $N\cdot\log_2 N$ time rise.
The following information stems from \cite{Press},
where the theoretical background is explained comprehensively.

\addvspace{12pt}

The fundamental trick of the FFT is to cut the DFT into two parts,
one with data having even indices and the other with odd indices:

\begin{eqnarray}
\underline{U}_n & = &
  \sum_{k=0}^{N-1} u_k\cdot \exp\left( -j\cdot n\frac{2\pi\cdot k}{N} \right) \\
  & = & \sum_{k=0}^{N/2-1} u_{2k}\cdot
        \exp\left( -j\cdot n\frac{2\pi\cdot 2k}{N} \right) +
        \sum_{k=0}^{N/2-1} u_{2k+1}\cdot
        \exp\left( -j\cdot n\frac{2\pi\cdot (2k+1)}{N} \right) \\
  & = & \underbrace{ \sum_{k=0}^{N/2-1} u_{2k}\cdot
        \exp\left( -j\cdot n\frac{2\pi\cdot k}{N/2} \right) }_{F_{even}} +
        W_{n,N}\cdot \underbrace{ \sum_{k=0}^{N/2-1} u_{2k+1}\cdot
        \exp\left( -j\cdot n\frac{2\pi\cdot k}{N/2} \right) }_{F_{odd}} \\
\text{with} & & W_{n,N} = \exp\left( 2\pi\cdot j\cdot \frac{n}{N} \right)
\end{eqnarray}

The new formula shows no speed advantages. The important thing is that
the even as well as the odd part each is again a Fourier series. Thus
the same procedure can be repeated again and again until the equation
consists of $N$ terms. Then, each term contains only one data $u_k$
with factor $e^0=1$. This works if the number of data is a power of
two (2, 4, 8, 16, 32, ...).
So finally, the FFT method performs $\log_2 N$ times the operation
\begin{equation}
\label{eqn:FFTstep}
u_{k1,even} + W_{n,x}\cdot u_{k2,odd}
\end{equation}

to get one data of $\underline{U}_n$. This is called the
Danielson-Lanzcos algorithm.
The question now arises which data values of $u_k$
needs to be combined according to equation \ref{eqn:FFTstep}.
The answer is quite easy. The data array must be reordered by the
bit-reversal method. This means the value at index $k_1$ is swapped
with the value at index $k_2$ where $k_2$ is obtained by mirroring
the binary number $k_1$, i.e. the most significant bit becomes the
least significant one and so on. Example for $N=8$:

\addvspace{12pt}

\begin{tabular}{ccccccccccc}
000 & $\leftrightarrow$ & 000  & \qquad\qquad &  011 & $\leftrightarrow$ & 110  & \qquad\qquad &  110 & $\leftrightarrow$ & 011 \\
001 & $\leftrightarrow$ & 100  & \qquad\qquad &  100 & $\leftrightarrow$ & 001  & \qquad\qquad &  111 & $\leftrightarrow$ & 111 \\
010 & $\leftrightarrow$ & 010  & \qquad\qquad &  101 & $\leftrightarrow$ & 101 \\
\end{tabular}

\addvspace{12pt}

Having this new indexing, the values to combine according to
equation \ref{eqn:FFTstep} are the adjacent values. So, performing
the Danielson-Lanzcos algorithm has now become very easy.

\addvspace{12pt}

Figure \ref{fig:fft} illustrates the whole FFT algorithm starting with the
input data $u_k$ and ending with one value of the output data
$\underline{U}_n$.

\begin{figure}[htb]
\begin{center}
\includegraphics[width=13cm]{fft}
\end{center}
\caption{principle of a FFT with data length 8}
\label{fig:fft}
\end{figure}
\FloatBarrier

This scheme alone gives no advantage. But it can compute all output
values within, i.e. no temporary memory is needed and the periocity
of $W_{n,N}$ is best exploited. To understand this, let's have a look
on the first Danielson-Lanczos step in figure \ref{fig:fft}. The four
multiplications and additions have to be performed for each output
value (here 8 times!). But indeed this is not true, because $W_{n,2}$
is 2-periodical in $n$ and furthermore $W_{n,2} = -W_{n+1,2}$. So now,
$u_0 + W_{0,2}\cdot u_4$ replaces the old $u_0$ value and
$u_0 - W_{0,2}\cdot u_4$ replaces the old $u_4$ value. Doing this for
all values, four multiplications and eight additions were performed
in order to calculate the first Danielson-Lanczos step for all (!!!)
output values. This goes on, as $W_{n,4}$ is 4-periodical in $n$ and
$W_{n,4} = -W_{n+2,4}$. So this time, two loop iterations (for $W_{n,4}$
and for $W_{n+1,4}$) are necessary to compute the current
Danielson-Lanczos step for all output values. This concept continues
until the last step.

Finally, a complete FFT source code should be presented. The original
version was taken from \cite{Press}. Several improvements were added
that gain about 10\% more speed. The function \texttt{SWAP(X, Y)}
exchanges the values in \texttt{X} and \texttt{Y}.

\addvspace{12pt}

Parameters:\\
\begin{tabular}{lcl}
\texttt{num}    & - & number of complex samples\\
\texttt{data[]} & - & array containing the data samples,\\
                &   & real and imaginary part in alternating order (length: 2*\texttt{num})\\
\texttt{isign}  & - & is 1 to calculate FFT and -1 to calculate inverse FFT
\end{tabular}

\addvspace{12pt}

\begin{lstlisting}[language=C++,
    caption={1D-FFT algorithm in C},
    numbers=left,
    basicstyle=\small,
    frame=single,
    fontadjust]
int i, j, m, n;
n = 2*num;
j = 0;

// bit reversal method
// 1) index 0 need not to be swapped
//    -> start at i=2
// 2) swap scheme is symmetrical
//    -> swap first and second half in one iteration
for (i=2; i<num; i+=2) {
  m = n/2;
  while (m >= 2 && j >= m) {  // calculate swap index
    j -= m;
    m >>= 1;
  }
  j += m;

  if(j > i) {   // was index already swapped ?
    SWAP(data[j], data[i]);   // swap real part
    SWAP(data[j+1], data[i+1]);   // swap imaginary part

    if(j < num) {  // swap second half ?
      Swap (data[n-j-2], data[n-i-2]); // swap real part
      Swap (data[n-j-1], data[n-i-1]); // swap imaginary part
    }
  }
 }

// Danielson-Lanzcos algorithm
int mmax, istep;
double wt, theta, wr, wi, wpr, wpi, tempi, tempr;
mmax = 2;
while (n > mmax) { // each Danielson-Lanzcos step
  istep = mmax << 1;
  theta = isign * (2*pi/mmax);
  wpr = cos(theta);
  wpi = sin(theta);
  wr = 1.0;
  wi = 0.0;
  for (m=1; m<mmax; m+=2) {
    for (i=m; i<=n; i+=istep) {
      j = i+mmax;
      tempr = wr*data[j-1] - wi*data[j];
      tempi = wr*data[j] + wi*data[j-1];
      data[j-1] = data[i-1] - tempr;
      data[j] = data[i] - tempi;
      data[i-1] += tempr;
      data[i] += tempi;
    }
    wt = wr;
    wr = wt*wpr - wi*wpi;
    wi = wi*wpr + wt*wpi;
  }
  mmax = istep;
}
\end{lstlisting}

\addvspace{12pt}

If real time values should be transformed, then the second half
of the frequency values are the conjugate complex of the first half.
Therefore, \texttt{n} in line line 30 can be replaced be \texttt{num}.

\addvspace{12pt}

There are many other FFT algorithms mainly aiming at higher speed.
Two that are worth mentioning are base-4 FFT (about 20\% faster)
and the Winograd Fourier transform algorithm (up to 100\% faster).
However, the algorithms are much more complex.

\addvspace{12pt}

A standard Fourier Transformation is not useful in harmonic balance
methods, because with multi-tone excitation many mixing products appear.
The best way to cope with this problem is to use multi-dimensional
FFT.

\addvspace{12pt}

Fourier Transformations in more than one dimension soon become
very time consuming. Using FFT mechanisms is therefore mandatory.
A more-dimensional Fourier Transformation consists of many
one-dimensional Fourier Transformations (1D-FFT). First, 1D-FFTs
are performed for the data of the first dimension at every index
of the second dimension. The results are used as input data for
the second dimension that is performed the same way with respect
to the third dimension. This procedure is continued until all
dimensions are calculated. The following equations shows this
for two dimensions.

\begin{eqnarray}
\underline{U}_{n1,n2} & = & \sum_{k_2=0}^{N_2-1} \sum_{k_1=0}^{N_1-1}
   u_{k_1,k_2}\cdot \exp\left( -j\cdot n_1\frac{2\pi\cdot k_1}{N_1} \right)
              \cdot \exp\left( -j\cdot n_2\frac{2\pi\cdot k_2}{N_2} \right) \\
 & = & \sum_{k_2=0}^{N_2-1} \exp\left( -j\cdot n_2\frac{2\pi\cdot k_2}{N_2} \right)
       \cdot \underbrace{ \sum_{k_1=0}^{N_1-1}
   u_{k_1,k_2}\cdot \exp\left( -j\cdot n_1\frac{2\pi\cdot k_1}{N_1} \right) }_\text{1D-FFT}
\end{eqnarray}


Finally, a complete $n$-dimensional FFT source code should be
presented. It was taken from \cite{Press}.

\addvspace{12pt}

Parameters:\\
\begin{tabular}{lcl}
\texttt{ndim}   & - & number of dimensions\\
\texttt{num[]}  & - & array containing the number of complex samples for every dimension\\
\texttt{data[]} & - & array containing the data samples,\\
                &   & real and imaginary part in alternating order (length: 2*sum of \texttt{num[]}),\\
                &   & going through the array, the first dimension changes least rapidly !\\
                &   & all subscripts range from 1 to maximum value !\\
\texttt{isign}  & - & is 1 to calculate FFT and -1 to calculate inverse FFT
\end{tabular}

\addvspace{12pt}

\begin{lstlisting}[language=C++,
    caption={multidimensional FFT algorithm in C},
    numbers=left,
    basicstyle=\small,
    frame=single,
    fontadjust]
int idim, i1, i2, i3, i2rev, i3rev, ip1, ip2, ip3, ifp1, ifp2;
int ibit, k1, k2, n, nprev, nrem, ntot;
double tempi, tempr, wtemp, theta, wr, wi, wpi, wpr;

ntot = 1;
for (idim=0; idim<ndim; idim++) // compute total number of complex values
  ntot *= num[idim];

nprev = 1;
for (idim=ndim-1; idim>=0; idim--) { // main loop over the dimensions
  n = num[idim];
  nrem = ntot/(n*nprev);
  ip1 = nprev << 1;
  ip2 = ip1*n;
  ip3 = ip2*nrem;
  i2rev = 1;

  for (i2=1; i2<=ip2; i2+=ip1) { // bit-reversal method
    if (i2 < i2rev) {
      for (i1=i2; i1<=i2+ip1-2; i1+=2) {
	for (i3=i1; i3<=ip3; i3+=ip2) {
	  i3rev = i2rev+i3-i2;
	  SWAP(data[i3-1],data[i3rev-1]);
	  SWAP(data[i3],data[i3rev]);
	}
      }
    }
    ibit=ip2 >> 1;
    while (ibit >= ip1 && i2rev > ibit) {
      i2rev -= ibit;
      ibit >>= 1;
    }
    i2rev += ibit;
  }

  ifp1 = ip1;
  while (ifp1 < ip2) { // Danielson-Lanzcos algorithm
    ifp2 = ifp1 << 1;
    theta = isign*2*pi/(ifp2/ip1);
    wtemp = sin(0.5*theta);
    wpr = -2.0*wtemp*wtemp;
    wpi = sin(theta);
    wr = 1.0; wi = 0.0;
    for (i3=1; i3<=ifp1; i3+=ip1) {
      for (i1=i3; i1<=i3+ip1-2; i1+=2) {
	for (i2=i1; i2<=ip3; i2+=ifp2) {
	  k1 = i2;
	  k2 = k1+ifp1;
	  tempr = wr*data[k2-1] - wi*data[k2];
	  tempi = wr*data[k2] + wi*data[k2-1];
	  data[k2-1] = data[k1-1] - tempr;
	  data[k2] = data[k1] - tempi;
	  data[k1-1] += tempr; data[k1] += tempi;
	}
      }
      wr = (wtemp=wr)*wpr-wi*wpi+wr;
      wi = wi*wpr+wtemp*wpi+wi;
    }
    ifp1 = ifp2;
  }
  nprev *= n;
}
\end{lstlisting}


\subsection{Starting Values}

A difficult question is how to find appropriate start values for the
harmonic balance simulation. It is recommended to first perform a DC
analysis and start the algorithm with this result. In many situation
(perhaps always) an even better starting point can be achieved by
also using the result of a linear AC simulation. However with a large
signal strength and strong non-linearities, convergence may still
fail. Then, the following procedure might succeed: Perform HB
simulation by applying half of the desired signal levels. If convergence
is reached, the result can be used as start values for the simulation
with the full signal levels. Otherwise the amplitude of the signals can
be further decreased in order to repeat the above-mentioned procedure.


\subsection{Solution algorithm}

To perform a HB simulation, the multi-dimensional, non-linear function
\ref{eqn:HBeqn} has to be solved. One of the best possibilities to
do so is the Newton method:
\begin{equation}
\textbf{V}_{n+1} = \textbf{V}_n - \textbf{J}_F (\textbf{V}_n)^{-1}
                   \cdot \textbf{F} (\textbf{V}_n)
\end{equation}
\begin{equation}
\label{eqn:HBnewton}
\Rightarrow \qquad \textbf{J}_F (\textbf{V}_n) \cdot \textbf{V}_{n+1}
    = \textbf{J}_F (\textbf{V}_n) \cdot \textbf{V}_n - \textbf{F} (\textbf{V}_n)
\end{equation}
with $\textbf{J}_F$ being the Jacobian matrix. DC and transient
simulation also use this technique, but here a problem appears:
The derivatives of the component models are not given in frequency
domain. Thus, the Jacobian must be calculated starting at the HB
equation \ref{eqn:HBeqn}:
\begin{equation}
\label{eqn:HBjacobi}
\boldsymbol{J}_F (\boldsymbol{V}_n) = \frac{d\boldsymbol{F} (\boldsymbol{V})}{d\boldsymbol{V}}
    = \boldsymbol{\hat{Y}}_{N \times N} + \frac{\partial \boldsymbol{I}_G}{\partial \boldsymbol{V}}
     + j\cdot \boldsymbol{\Omega}\frac{\partial \boldsymbol{Q}}{\partial \boldsymbol{V}}
    = \boldsymbol{\hat{Y}}_{N \times N} + \boldsymbol{J}_{F,G}
     + j\cdot \boldsymbol{\Omega}\cdot\boldsymbol{J}_{F,Q}
\end{equation}
So, two Jacobian matrices have to be built, one for the current
$\boldsymbol{I}_G$ and one for the charge $\boldsymbol{Q}$. Both resulted
from a Fourier Transformation. The two operations (Fourier Transformation
and differentiation) are linear and thus, can be exchanged. Hence, the
Jacobian matrices
are built in time domain and transformed into frequency domain afterwards.

\addvspace{12pt}

To obtain a practical algorithm of this procedure, the DFT is best written
as matrix equation. By having a look at equation \ref{eqn:DFT} and
\ref{eqn:IDFT}, it becomes clear how this works. The harmonic factors
$\exp(j\omega_k t_n)$ build the matrix $\boldsymbol{\Gamma}$:
\begin{align}
\text{DFT:}  \qquad & \boldsymbol{U}(j\omega) = \boldsymbol{\Gamma}\cdot \boldsymbol{u}(t) \\
\text{IDFT:} \qquad & \boldsymbol{u}(t) = \boldsymbol{\Gamma}^{-1}\cdot \boldsymbol{U}(j\omega)
\end{align}
with $\boldsymbol{u}$ and $\boldsymbol{U}$ being the vectors of the time
and frequency values, respectively. Now, it is possible to transform the
desired Jacobian matrix into frequency domain:
\begin{equation}
\label{eqn:HB_jacobi}
\boldsymbol{J}_{F,G}
  = \frac{\partial\boldsymbol{I}_G}{\partial\boldsymbol{V}}
  = \frac{\partial(\boldsymbol{\Gamma}\cdot\boldsymbol{i})}
         {\partial(\boldsymbol{\Gamma}\cdot\boldsymbol{v})}
  = \boldsymbol{\Gamma}\cdot\frac{\partial\boldsymbol{i}}{\partial\boldsymbol{v}}
    \cdot\boldsymbol{\Gamma}^{-1}
\end{equation}
Here $\boldsymbol{i}$ is a vector with length $K\cdot N$, i.e. first all
time values of the first node are inserted, then all time values of the
second node etc. The Jacobi matrix of $\boldsymbol{i}$ is defined as:
\begin{equation}
\boldsymbol{J}_{F,G}(\boldsymbol{u}) =
\begin{bmatrix}
\dfrac{\partial i_1}{\partial u_1} & \hdots & \dfrac{\partial i_1}{\partial u_n} \\
\vdots & \ddots & \vdots\\
\dfrac{\partial i_n}{\partial u_1} & \hdots & \dfrac{\partial i_n}{\partial u_n} \\
\end{bmatrix}
\end{equation}
Hence this matrix consists of
$K \times K$ blocks (one for each node) that are diagonal matrices with
time values of the derivatives in it. (Components exists that create
non-diagonal blocks, but these are so special ones that they do not appear
in this document.)

\addvspace{12pt}

The formula \ref{eqn:HB_jacobi} seems to be quite clear, but it has to be pointed out how
this works with FFT algorithm. With
$\boldsymbol{\Gamma}^{-1} = (\boldsymbol{\Gamma}^{-1})^T$
(see equation \ref{eqn:IDFT}) and
$(\boldsymbol{A}\cdot\boldsymbol{B})^T = \boldsymbol{B}^T\cdot \boldsymbol{A}^T$,
it follows:
\begin{equation}
\boldsymbol{J}_{F,G}
  = \boldsymbol{\Gamma}\cdot\frac{\partial\boldsymbol{i}}{\partial\boldsymbol{v}}
    \cdot\boldsymbol{\Gamma}^{-1}
  = \left( \boldsymbol{\Gamma}^{-1}\cdot \left( \boldsymbol{\Gamma} \cdot
    \frac{\partial\boldsymbol{i}}{\partial\boldsymbol{v}} \right)^T \right)^T
\end{equation}
So, there are two steps to perform an FFT-based transformation of the time
domain Jacobian matrix into the frequency domain Jacobian:
\begin{enumerate}
\item Perform an FFT on every column of the Jacobian and build a new matrix
      $\boldsymbol{A}$ with this result, i.e. the first column of
      $\boldsymbol{A}$ is the FFTed first column of the Jacobian and so on.
\item Perform an IFFT on every row of the matrix $\boldsymbol{A}$ and build
      a new matrix $\boldsymbol{B}$ with this result, i.e. the first row of
      $\boldsymbol{B}$ is the IFFTed first row of $\boldsymbol{A}$ and so on.
\end{enumerate}
As the Fourier transformation has to be applied to diagonal sub-matrices,
the whole above-mentioned process can be performed by one single FFT. This
is done by taking the $\partial\boldsymbol{i} / \partial\boldsymbol{v}$
values in a vector $\boldsymbol{J}_i$ and calculating:
\begin{equation}
\dfrac{1}{K}\cdot\text{FFT}\left(\boldsymbol{J}_i\right)
\end{equation}
The result is the first column of $\boldsymbol{J}_{F,G}$. The second column
equals the first one rotated down by one element. The third column is the
second one rotated down by one element etc.

\addvspace{12pt}

So, finally the complete HB Newton iteration step can be written down.
Putting \ref{eqn:HBeqn} and \ref{eqn:HBjacobi} into  \ref{eqn:HBnewton}
leads to
\begin{equation}
\textbf{J}_F (\textbf{V}_n) \cdot \textbf{V}_{n+1}
  = \textbf{J}_{F,G} \cdot \textbf{V}_n - \textbf{I}_G +
    j\cdot \boldsymbol{\Omega}\cdot (\textbf{J}_{F,Q}\cdot\textbf{V}_n - \textbf{Q}) -
    \textbf{I}_S
\end{equation}
This is important to notice, because many non-linear components
cannot be processed at every bias point (see figure \ref{fig:NewtonBad}).
These components create a new voltage estimate across their nodes,
whereas the new estimated absolute voltages at their nodes are not
known. Thus, the term $\textbf{J}_{F,G} \cdot \textbf{V}_n$ can
only be created in one single step, leading to the vector
$\textbf{I}_{G,J}$. Luckily, this procedure also saves computation
time, as the matrix multiplication need not to be performed.
The same is true for the term $\textbf{J}_{F,Q}\cdot\textbf{V}_n$,
leading to the vector $\textbf{Q}_J$. So it is:
\begin{equation}
\textbf{J}_F \cdot \textbf{V}_{n+1}
  = \textbf{I}_{G,J} - \textbf{I}_G +
    j\cdot \boldsymbol{\Omega}\cdot (\textbf{Q}_J - \textbf{Q}) -
    \textbf{I}_S
\end{equation}


\subsection{Termination Criteria}

Frequency components with very different magnitude appear in harmonic
balance simulation. In order to detect when the solver has found an
accurate solution, an absolute as well as relative criteria must be
used on all nodes and at all frequencies. The analysis is regarded as
finished if one of the criteria is satisfied.

\addvspace{12pt}

The absolute and relative criteria write as follows:
\begin{align}
\left| \tilde{I}_{n,k} + \hat{I}_{n,k} \right| &< \varepsilon_{abs}
   &\forall \quad n, k\\
2\cdot \left| \frac{\tilde{I}_{n,k} + \hat{I}_{n,k}}
                   {\tilde{I}_{n,k} - \hat{I}_{n,k}} \right|
  &< \varepsilon_{rel}  &\forall \quad n, k
\end{align}
where $\tilde{I}_{n,k}$ is the current of the linear circuit
partition for node $n$ and frequency $k$ and $\hat{I}_{n,k}$
is the current of the non-linear circuit partition.


\section{A Symbolic HB Algorithm}

In this final section, a harmonic balance algorithm in symbolic language is
presented.

\addvspace{12pt}

\begin{lstlisting}[language=C++,
    caption={symbolic HB algorithm},
    basicstyle=\small,
    frame=single,
    mathescape=true,
    fontadjust]
 init();                    // separate linear and non-linear devices
 Y = calcTransMatrix();     // transadmittance matrix of linear circuit
 Is = calcSourceCurrent();  // source current of linear subcircuit
 (v, i, q) = calculateDC(); // DC simulation as initial HB estimate
 V = FFT(v);                // transform voltage into frequency domain

 loop:
   I = FFT(i);                       // current into frequency domain
   Q = FFT(q);                       // charge into frequency domain
   E = Is + Y*V + j*$\Omega$*Q + I;          // HB equation
   if (abs(E) < Eterm) break;       // convergence reached ?
   JG = mFFT(GJacobian(v));          // create Jacobians and transform...
   JQ = mFFT(QJacobian(v));          // ... them into frequency domain
   J = Y + j*$\Omega$*JQ + JG;               // calculate overall Jacobian
   V = V - invert(J) * E;            // Newton Raphson iteration step
   v = IFFT(V);                      // voltage into time domain
   i = nonlinearCurrent(v);          // use component models to get...
   q = nonlinearCharge(v);           // ... values for next iteration
   goto loop;

 Va = invert(Ya) * Ia;               // AC simulation to get all voltages
\end{lstlisting}

\section{Large-Signal S-Parameter Simulation}

Using harmonic balance techniques, it is also possible to perform
an S-parameter simulation in the large-signal regime. This is called
LSSP (large-signal s-parameter). Figure \ref{fig:lssp} shows the
principle. The port $n$ excites the circuit with the simulation
frequency $f_0$; meanwhile the power of all other ports is set to
zero. Having voltage and current of the fundamental frequency $f_0$
at the ports, the S-parameters can be calculated:

\begin{equation}
\label{eqn:ui2s}
\underline{S}_{mn} = \frac{\underline{U}_m(f_0) - \underline{I}_m(f_0)\cdot Z_m}
                          {\underline{U}_n(f_0) + \underline{I}_n(f_0)\cdot Z_n}
		\cdot \sqrt{\frac{Z_n}{Z_m}}
\end{equation}

\begin{figure}[htb]
\begin{center}
\includegraphics[width=7cm]{lssp}
\end{center}
\caption{S-parameter from AC voltages and currents}
\label{fig:lssp}
\end{figure}
\FloatBarrier

An algorithm in symbolic language should describe the whole LSSP:

\addvspace{12pt}

\begin{lstlisting}[language=C++,
    caption={symbolic HB algorithm},
    basicstyle=\small,
    frame=single,
    mathescape=true,
    fontadjust]
for n=1 to $NumberOfPorts$ {
  Set power of port $n$ to $P_n$.
  Set power of ports $\ne n$ to 0.
  Perform Harmonic Balance.

  for m=1 to $NumberOfPorts$
    Calculate $\underline{S}_{mn}$ according to above-mentioned equation.
}
\end{lstlisting}
